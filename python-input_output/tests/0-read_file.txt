Test cases for read_file function

Test Case 1: Read existing file
- Create a test file with known content (e.g., "Hello, World!")
- Call read_file with the test file path
- Verify output matches the file content
- Expected: File content is printed to stdout exactly as is

Test Case 2: Empty file
- Create an empty test file
- Call read_file with the empty file path
- Expected: No output (empty string printed)

Test Case 3: File with special characters
- Create a test file with special characters and newlines
  Example content:
  "Line 1\nLine 2 with special chars: éàè@#$"
- Call read_file with this file
- Expected: Exact content is printed including special chars and newlines

Test Case 4: Non-existent file (Error case)
- Call read_file with a non-existent file path
- Expected: FileNotFoundError should be raised

Test Case 5: No filename provided
- Call read_file() without arguments
- Expected: Should raise TypeError (missing 1 required positional argument)

Test Case 6: Read the script itself
- Call read_file("0-read_file.py")
- Expected: Should print the content of 0-read_file.py

Edge Cases:
- File with very long lines
- File with different encodings (UTF-8, etc.)
- File with different line endings (\n vs \r\n)
- File with binary content (though the function is meant for text files)

Note: For actual implementation, you would typically use a testing framework like unittest or pytest, but since the requirement is a .txt file, these are the test cases to implement.
